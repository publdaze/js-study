**✅ 원시타입과 참조타입의 차이점은 무엇인가요?**

- **원시 타입**은 변경 불가능(읽기 전용)하며, 변수에 값이 직접 저장됩니다. `값에 의한 전달`
  - 그렇기 때문에 변수에 값을 재할당한다는 것은, 값을 직접 바꾸는게 아니라, 새로운 메모리 공간을 확보하고, 변수가 새로운 메모리로 교체하게 됩니다.
- **참조 타입**은 변경 가능하며, 변수에는 해당 객체의 메모리 주소가 저장됩니다. `참조에 의한 전달`
  - 참조 타입은 어떤 타입의 값이 들어갈지 모르고, 가변적인 크기 때문에, 미리 여유롭게 메모리를 확보합니다.

**✅ 불변성을 지니는 원시타입의 장점은 무엇인가요?**

- 원시값은 항상 변하지 않으므로, 데이터의 신뢰성을 보장합니다.

**✅ 상수와 불변의 차이는 무엇인가요?**

- 불변이란, 메모리에 들어있는 값을 변경하지 못합니다. 원시타입의 경우 불변성을 지니기에, 메모리의 값을 직접 수정하지 못하고, 값을 재할당하기 위해서는 새로운 메모리를 할당받아야합니다.
- 상수란, 값을 재할당하지 못하는 변수입니다.
- 그렇기 때문에 불변이란 메모리영역 관점에서 메모리 값을 못 바꾼다는 것이고, 상수는 재할당이 불가능한 것입니다.

**✅ 원시 값과 객체는 메모리 영역 중 각각 어디에 저장이 되나요? 해당 메모리 영역을 사용하는 이유도 말해주세요.**

- 원시타입은 메모리 스택영역에 저장되고, 참조타입은 힙 영역에 저장됩니다.
- 참조타입(객체)의 경우, 동적으로 크기가 변할 수 있기 때문에 힙 영역에 저장하며, 원시타입의 경우 불변성을 지니고, 크기가 고정되어있어 스택영역에 할당된다.

**✅ 객체를 불변하게 만들기 위해 어떤 방법을 사용할 수 있나요?**

- `object.freeze`
  - 해당 방법은 객체의 중첩된 객체까지는 동결시키지 못합니다. 즉, 한단계까지만 동결을 시키는데요.
  - 중첩된 객체까지 동결하기 위해서는 재귀적으로 `object.freeze` 를 사용해야합니다.
  - 그러나, 해당 방법은 객체의 프로퍼티를 변경할 수는 없지만, 만약 let, var 로 선언할 경우, 객체의 재할당은 가능합니다.
  - 그렇기 때문에 `const`로 선언하여 재할당까지 막아준다면, 객체의 재할당과 내부 속성 변경 모두를 막을 수 있습니다.

**✅ const 키워드의 특징은?**

- const는 재할당(변수 값 교체)이 불가능합니다.

**✅ const로 선언한 객체를 수정할 수 있는 이유는 무엇인가요?**

- 객체는 기본적으로 원시타입과 다르게 값이 아닌, 메모리주소를 저장합니다.
- 이 메모리 주소는 또 다시 객체가 담긴 값들의 주소를 저장하는데요, 그렇기 때문에 객체의 값을 수정한다는 것은, 실제로는 한단계를 더 거쳐서 값이 변하는 거라, 1차적인 변수가 저장하는 메모리 주소는 변하지 않습니다.

**✅ 객체와 같은 참조타입은 왜 원시타입과 다르게 변경가능한 값으로 설계되었는지 설명해주세요. 객체가 불변성을 지키면 안되는걸까요?**

- 객체타입도 불변성을 지키려면, 많은 비용과 메모리가 듭니다. 원시타입의 경우 불변성을 지키기 위해, 아예 새로운 메모리 공간을 할당하는데, 크기가 큰 객체를 전부 복사하는 비용이 클 것입니다.

**✅ 참조타입 값들은 어떻게 여러 타입이 가능한가**요?

- 참조타입의 값, 예를 들어 배열에 들어가는 원소들은, 원시타입처럼 값을 직접 저장하는게 아니라, 값이 저장된 메모리 주소를 참조합니다. (참조타입의 배열이 메모리 주소를 참조하는 것 뿐만 아니라, 배열의 원소들도 메모리 주소를 참조. 한단계를 더 거치는 것)
- 즉, 배열 요소는 메모리 주소를 참조하므로, 서로 다른 타입의 데이터를 저장할 수 있습니다.

**✅ C언어의 경우, 배열에는 특정 타입의 데이터만 들어가는데요, 이러한 방식의 장점은 무엇인가요?**

- 메모리 관리가 효율적입니다.
- 자바스크립트는, 참조타입에 무슨 값이 들어갈지 모르기 때문에, 여유로운 메모리 확보가 필요합니다. 반면 c언어는 모든 요소가 동일한 크기이기에, 미리 예측이 가능하여 효율적인 관리가 가능합니다.

**✅ 참조에 의한 전달의 문제점은 무엇인가요?**

- 여러개의 식별자가 하나의 객체를 공유한다. → 객체를 변경하면. 서로 영향을 주고받는다.

**✅ 얕은 복사와 깊은 복사에 대해 설명해주세요.**

- `얕은 복사` : 한단계만. 참조값을 복사
- `깊은 복사` : 중첩객체까지 싹다.
  **✅ 1차원 객체를 얕은복사하는 방법에는 무엇이 있나요?**
  - =, Object.assign(), 스프레드,
    **✅ 2차원 이상의 객체를 깊은 복사하는 방법에는 무엇이 있나요?**
  - JSON.parse && JSON.stringify, lodash

**✅  객체를 복사할 때 발생할 수 있는 문제점은 무엇인가요?**

- 자바스크립트에서 객체를 복사하는 방법에는 얕은 복사, 깊은 복사가 있는데,
- 만약 얕은 복사의 경우, 참조값을 복사하기 때문에, 여러개의 식별자가 하나의 메모리주소를 공유하게 됩니다. 이는 복사된 객체를 수정하면, 원본 객체까지 변경되는 이슈가 존재합니다.

**✅ 자바스크립트에서 문자열의 메모리 공간 크기는 어떻게 결정이 되나요? 숫자타입과 어떤점이 다른가요?**

- 숫자타입은 숫자가 무엇이던간에(1, 100) `8바이트`를 차지하는 반면, 문자열의 경우, 1개의 문자가 `2바이트`를 차지합니다. 그렇기에 문자가 길어질수록, 메모리 공간은 더 차지하게 됩니다.

**✅ 자바스크립트에서 문자열의 경우, 배열처럼 인덱스에 접근이 가능합니다. 가능한 이유가 무엇인가요?**

- 유사배열이기 때문에 배열처럼 인덱스를 통한 접근이나, .length와 같은 메서드를 사용가능합니다.
- 원시타입인 문자열을 배열처럼 접근하려고 할때, 자바스크립트 문자열을 임시로 객체로 만들어주어, 프로퍼티를 사용할 수 있게 해줍니다. 이때 만들어지는 객체를 래퍼객체라고 합니다.

**✅ 객체의 프로퍼티 접근 방법에는 어떤 것들이 있나요?**

- 대괄호 표기법(`[]`)과 점 표기법(`.`)이 있습니다

**✅  점 표기법과 대괄호 표기법은 각각 어떤 상황에서 사용하나요?**

- 점 표기법의 경우, 변수 네이밍 규칙을 따를 경우, 예를 들어 숫자로 시작하지 않고, 문자, \_ 등으로 시작되는 경우에만 사용 가능합니다.
- 대괄호 표기법의 경우, 속성을 문자열로 접근하기 때문에, 변수 네이밍 규칙을 지키지 않더라도 사용가능합니다.

**✅ 원시값을 비교하는 방법에는 무엇이 있나요?**

- `===` 일치연산자, `==` 동등 연산자
- `===` 원시값의 타입과 값 모두 비교. 타입변환이 일어나지 않아 안전.
- `==` 원시값의 값만 비교 → 암묵적 타입변환이 이뤄진다.

**✅ 객체를 비교하는 방법에는 무엇이 있나요?**

- `===` 일치연산자와, `Object.is` 를 사용할 수 있습니다.
- `===` NaN === NaN : false, +0 === -0 : true
- `Object.is` NaN === NaN : true, +0 === -0 : false

**✅ 함수에 객체를 전달할 때 참조에 의한 전달과 값에 의한 전달의 차이를 설명해보세요.**

- 값에 의한 전달은, 원시값을 복사하여 함수의 인자로 전달합니다. 그렇기에 함수내부에서 값을 변경하더라도, 원본값에는 변화가 없습니다.
- 참조에 의한 전달은, 메모리 주소가 전달됩니다. 이에 인자로 받은 객체을 변경하면 원본 객체까지 수정되는 문제가 있습니다.
