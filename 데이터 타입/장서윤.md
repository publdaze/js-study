**✅ 데이터 타입에는 무엇이 있나요?**

- 원시 타입(`변경불가능`)
  - 숫자(number) - 모두 실수로 취급
  - 문자열(string), 불리언(boolean), undefined, null,
  - 심볼(Symbol) - 객체 프로퍼티를 고유값으로 사용
- 참조 타입(`변경 가능`) : 객체, 배열, 함수
- **✅ 문자열 타입 - 템플릿 리터럴의 장점을 설명해주세요.**
  - 백틱을 사용하는데, 백틱내부에서 줄바꿈이 적용되며, 표현식을 삽입할 수 있기에, 일반 따옴표, 쌍따옴표보다 가독성이 증가합니다.
    - **✅ 표현식을 삽입할 때 템플릿 리터럴을 사용하지 않고 문자열을 삽입하는 방법**
      1. `+` 연산자
      2. **`String`** 객체의 **`concat`** 메서드
      3. 배열의 **`join`** 메서드
- **✅ undefined와 null의 차이는 무엇인가요?**
  - `undefined`는 자바스크립트 엔진이 변수를 초기화할때 사용합니다. 그렇기에 의도적으로 개발자가 값이 없음을 나타내려면 `null` 을 사용하면 됩니다.
    `null` 이 담긴 값은 은 추후 메모리에서 해제됩니다.

**✅ 원시타입과 참조타입의 차이점은 무엇인가요?**

- 원시 타입은 변경 불가능하며, 변수에 값이 직접 저장됩니다. 그렇기 때문에, 변수에 값을 재할당한다는 것은, 값을 직접 바꾸는게 아니라, 새로운 메모리 공간을 확보하고, 변수가 새로운 메모리로 교체하게 됩니다.
- 참조 타입은 변경 가능하며, 변수에는 해당 객체의 메모리 주소가 저장됩니다.
  참조 타입은 어떤 타입의 값이 들어갈지 모르고, 가변적인 크기 때문에, 미리 여유롭게 메모리를 확보합니다.

- **✅ 참조타입 값들은 어떻게 여러 타입이 가능한가요?**

  - 참조타입의 값, 예를 들어 배열에 들어가는 원소들은, 원시타입처럼 값을 직접 저장하는게 아니라, 값이 저장된 메모리 주소를 참조합니다. (참조타입의 배열이 메모리 주소를 참조하는 것 뿐만 아니라, 배열의 원소들도 메모리 주소를 참조. 한단계를 더 거치는 것)
  - 즉, 배열 요소는 메모리 주소를 참조하므로, 서로 다른 타입의 데이터를 저장할 수 있습니다.

- **✅ C언어의 경우, 배열에는 특정 타입의 데이터만 들어가는데요, 이러한 방식의 장점은 무엇인가요?**
  - 메모리 관리가 효율적입니다.
  - 자바스크립트는, 참조타입에 무슨 값이 들어갈지 모르기 때문에, 여유로운 메모리 확보가 필요합니다. 반면 c언어는 모든 요소가 동일한 크기이기에, 미리 예측이 가능하여 효율적인 관리가 가능합니다.

**✅ typeof 연산자와 instanceof 연산자의 차이점은 무엇인가요?**

- typeof은 해당하는 타입을 문자열로 반환하는 반면, instanceof는 특정 클래스에 속하는 객체인지 여부(true/false)를 반환합니다.

**✅ 데이터 타입이 필요한 이유는 무엇이라고 생각하시나요?**

- 값을 저장할때 확보해야할 메모리 공간의 크기를 알아야 함
- 값을 참조할때 읽어들여야할 메모리 공간의 크기를 알아야 함
- 메모리 값(2진수)을 어떻게 해석할건지 알아야 함

**✅ 동적타입언어인 자바스크립트의 특징을 말해주세요**

- 정적타입언어 (c, c++, java, **TypeScript**)
  - 컴파일 시점에서 타입 체크. 불일치할 경우 실행자체를 막음
    - 컴파일 : 문법 에러, 타입 체크
  - 에러 : `컴파일`, `유연성 감소`, `신뢰도 증가`,
- 동적타입언어 (**JavaScript**)
  - 런타임 시점, 소스코드를 실행하며, 값을 **할당**하는 시점에서 **타입이 결정**. 재할당에 의해 타입이 바뀜
    - 런타임 : 메모리 부족, 0나누기
  - 에러 : `런타임`, `유연성 증가`, `신뢰도 감소` \*\*\*\*
- **✅  프로젝트에서 어떤 언어를 사용해야한다고 생각하시나요?**
  - 프로젝트 규모와 사용하는 언어에 따라 다르게 선택할 것 같습니다.
  - 프로젝트 규모가 작거나, 이미 **JavaScript로** 개발이 많이 진행되어있다면, 속도와 유연성을 위해 자바스크립트를 선택할 것 같습니다.
  - 그러나, 프로젝트 규모가 크고, 안정성이 중요하다면 TypeScript를 사용할 것 같습니다.
  - 개인적으로 코드를 작성할 때 IDE에서 자동 완성 기능을 제공하고, 타입 관련 에러를 사전에 파악할 수 있기에 타입스크립트를 선호하는 편입니다.

**✅ 명시적 타입변환과 암묵적 타입변환이 무엇인지 설명해주세요.**

- 명시적 타입변환(타입 캐스팅) : 개발자가 의도적으로 값의 타입을 변환
  - new 연산자 없이 표준 빌트인 함수(String, Number) 호출
    - **✅** `new` **연산자없이 호출하는 이유는 무엇인가요?**
      - `new` 로 만들 경우, 원시값이 아니라 객체를 반환하기 때문.
  - 빌트인 메서드 사용(`toString()`)
  - 암묵적 타입변환 사용
- 암묵적 타입변환(타입강제변환) : 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환
  - 산술연산자 (`+`,`-`,`*`,`/`)
    - `+`
      - 단항 : 피연산자가 숫자가 아닌 경우, **숫자로 암묵적 타입변환!**
      - 이항 : 다른 피연산자가 문자열이 아닌 경우, **문자열로 암묵적 타입변환!**
    - `-`,`*`,`/` 산술연산자로 동작.
      - 이때, 다른 피연산자가 숫자가 아닌 경우, **숫자로 암묵적 타입변환!**
      - 만약, 숫자로 변환할 수 없다 → `NaN`으로!
  - 비교연산자
    - 비교연산자는 크기를 비교해야하므로, **숫자로 암묵적 타입변환!**
    - `“one” > 1` ⇒ false
      - `“one”` 을 숫자로 변환 → `NaN`
      - `NaN`은 어떤 숫자와도 비교할 수 없습니다. `NaN`과의 비교 ⇒ 항상 `false`
  - `Falsy` → `false`, `Truthy` → `true`, boolean으로 암묵적 타입 변환

**✅ 알아두기!**

- 타입변환은 이미 값이 할당된 원시값의 타입을 바꾸는게 아닙니다. (원시값은 변경불가능)
- 기존 값이 담긴 메모리를 변경하는게 아니라, 새로운 메모리를 만들고 새로운 타입의 원시값을 만드는 것입니다.

**✅ 명시적 타입변환과 암묵적 타입변환 중, 어떤 방법이 좋다고 생각하나요?**

- 상황에 따라 이해하기 암묵적 타입변환이 코드가 간결할 수 있겠지만, 실수를 방지하기 위해 명시적 타입변환을 사용하는 것이 좋다고 생각합니다.

**✅ Truthy / Falsy 한 값이 무엇인가요?**

- 자바스크립트 엔진은 boolean이 아닌 값들을 true, false대신 Truthy, Falsy로 구분합니다.
- 이는 조건식처럼 boolean으로 평가되어야할때, Truthy, Falsy가 true, false로 **암묵적 타입 변환**이 되어서 판별되는데요.
- `Falsy` : false, undefined, null, 0, -0, NaN, ‘’(빈 문자열) ⇒ `false` 로 평가된다.

**✅ 단축평가란 무엇인가요?**

- 표현식을 평가하는 도중에, 평가 결과가 확정된 경우, 나머지 평가과정은 생략하는 것입니다. 논리합(||), 논리곱(&&) 연산자가 있습니다.
- 논리합(||) 연산자는 좌항의 피연산자가 true일 경우, 우항의 피연산자를 평가하지 않고, 좌항의 피연산자를 반환합니다.
- 논리곱(&&) 연산자는 좌, 우 모두 true인지를 검사하기 때문에, 좌항이 false인경우 우항을 검사하지 않습니다.

**✅ 단축 평가를 활용해 기본값을 설정할 수 있나요?**

- 논리합 연산자(||)를 통해 기본값을 설정할 수 있습니다. 논리합 연산자는 좌항의 피연산자가 Falsy값일 경우, 우항의 피연산자를 반환하므로, 우항에 기본값을 넣어준다면, 비어있는 좌항대신 우항을 기본값으로 설정할 수 있습니다.
- 그러나 논리합 연산자는 Falsy를 기준으로 판단하기에, 좌항이 0, '' 일때도 기본값을 설정해버립니다.
- 만약 값이 없을때, 즉 값이 undefined/null일때만 기본값을 설정하고 싶다면, 논리합 연산자 대신 null 병합 연산자를 사용하는 것이 좋습니다.

**✅ 옵셔널 체이닝 연산자란 무엇인가요?**

- 좌항의 피연산자가 null/undefined 이라면 undefined를 반환하고, 아닐 경우 우항의 프로퍼티 참조를 이어간다 (`people?.name`)
- 이는 ES11에 나왔기에, 그전에는 논리곱(&&)로 좌항이 null/undefined 인지 판별했습니다. 그러나 논리곱(&&)은 null/undefined 뿐만 아니라 Falsy에 속하는지 판별합니다.
- **✅** **논리곱 연산자(&&)와 옵셔널 체이닝 연산자의 차이를 설명해주세요.**

  ```jsx
  people?.name; // == people && people.name
  ```

**✅ null 병합 연산자란 무엇인가요?**

- 좌항의 피연산자가 null/undefined 이라면 우항의 피연산자를 반환하고, 아닐 경우 좌항의 피연산자를 반환한다.
  - (`null ?? ‘default string’` ⇒`‘default string’` 반환)
  - (`'' ?? ‘default string’` ⇒`‘’` 반환)
