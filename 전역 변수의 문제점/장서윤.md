**✅ 변수의 생명주기는 무엇인가요?**

- 변수가 메모리에 할당되고, 해제될때까지의 시간입니다.
- ⇒ **함수가 호출**될때, 호이스팅이 일어나 변수가 선언되고 메모리에 할당됩니다. 그 후 함수가 종료될때까지의 시간입니다.
- **전역벽수, 지역객체의 생명주기는?**
  - 전역변수의 경우, 전역객체의 생명주기와 같으며, 지역변수의 경우 함수의 생명주기와 같습니다.
- **✅ 전역객체란 무엇인가요?**
  - 전역객체란, 코드가 실행되기전, 가장 먼저 생성되는 객체입니다.
  - 브라우저에서는 전역객체가 `window`이지만, nodeJs환경에서는 `global`이 전역객체입니다. (**자바스크립트를 사용하는 환경에 따라 다름**)
  - 전역객체는 String, Number와 같은 표준 빌트인 객체를 가지고 있고, setInterval, screen, navaigator등이 전역객체 아래에 속하며, 이때 window를 생략해서 사용할 수 있습니다.

**✅ 전역변수의 문제점은 무엇인가요?**

- **암묵적 결합** 의도치 않은 재할당, 어디서든 변수 참조가능.
- 생명주기가 길기에 메모리 차지.
- 스코프상에서 제일 마지막으로 검색.
- **✅ 네임스페이스 오염**
  - 파일이 분리되어있더라도, 하나의 전역 스코프를 공유하기 때문에, 각 파일에서 동일한 이름의 변수를 선언한다면, 값이 덮어씌게 되면서 의도치 않은 결과를 일으킵니다.

**✅ 전역변수의 대체 방법?**

- 즉시실행함수로 감싸서, 즉시실행함수의 지역변수로 만들어주는 방법
  - 이 방법은 하나의 모듈로 만들어서 사용가능합니다. 이때 클로저를 사용함. 내부에서만 접근 가능.
- 네임스페이스 객체를 만들어서, 전역변수가 필요하면, 해당 네임스페이스 객체의 속성으로 추가 ⇒ 네임스페이스 자체가 전역변수긴 함. 그렇지만, 식별자 충돌은 안날거임
- es6모듈 사용하면, 전역변수를 사용할 수 없습니다. es6모듈이 (파일별로) 독자적인 스코프를 제공해줍니다.
